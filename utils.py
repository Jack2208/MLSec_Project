import re
import os
import numpy as np
import matplotlib.pyplot as plt

def save_and_plot_all_norms(model, model_name, images, labels, adv_images_autoattack, adv_dict, output_dir, max_plots_to_show=1, scaling_factor=10):
    """
    Saves all adversarial perturbation plots to disk and displays a limited number on screen
    for each norm.

    Parameters:
        model: PyTorch model in evaluation mode.
        model_name: String name of the model (used for output directory structure).
        images: Original images tensor.
        labels: True labels tensor.
        adv_images_autoattack: Adversarial images generated by AutoAttack.
        adv_dict: Dictionary with norms as keys and adversarial images (from FMN) as values.
        output_dir: Base output directory to save images.
        max_plots_to_show: Maximum number of plots to display on screen per norm.
        scaling_factor: Factor to scale the perturbations for visualization.
    """
    # Set model to evaluation mode and compute predictions for AutoAttack adversarial images
    model.eval()
    autoattack_preds = model(adv_images_autoattack).argmax(dim=1).cpu().numpy()

    for norm, fmn_adv in adv_dict.items():
        # Create a directory for the current norm
        norm_output_dir = os.path.join(output_dir, model_name, f"{norm}_images")
        os.makedirs(norm_output_dir, exist_ok=True)

        # Get predictions for FMN adversarial images
        fmn_preds = model(fmn_adv).argmax(dim=1).cpu().numpy()

        for i in range(len(images)):
            fig, axes = plt.subplots(1, 5, figsize=(12, 3))

            # Prepare images for display and saving
            original = images[i].cpu().numpy().transpose(1, 2, 0)
            autoattack_img = adv_images_autoattack[i].cpu().numpy().transpose(1, 2, 0)
            fmn_img = fmn_adv[i].cpu().numpy().transpose(1, 2, 0)

            # Compute scaled perturbations
            autoattack_perturb = (autoattack_img - original) * scaling_factor
            fmn_perturb = (fmn_img - original) * scaling_factor

            # Plot the images and their predictions
            axes[0].imshow(np.clip(original, 0, 1))
            axes[0].set_title(f"Original\nLabel: {labels[i].item()}")

            axes[1].imshow(np.clip(autoattack_img, 0, 1))
            axes[1].set_title(f"AutoAttack\nPred: {autoattack_preds[i]}")

            axes[2].imshow(np.clip(fmn_img, 0, 1))
            axes[2].set_title(f"{norm}\nPred: {fmn_preds[i]}")

            axes[3].imshow(np.clip(autoattack_perturb, 0, 1))
            axes[3].set_title("AA Perturbation")

            axes[4].imshow(np.clip(fmn_perturb, 0, 1))
            axes[4].set_title(f"FMN ({norm}) Perturbation")

            for ax in axes:
                ax.axis("off")

            plt.tight_layout()

            # Save the plot on disk
            image_path = os.path.join(norm_output_dir, f"sample_{i}.png")
            plt.savefig(image_path)

            # Display only the first `max_plots_to_show` samples per norm
            if i < max_plots_to_show:
                plt.show()

            plt.close()

    print("Function execution completed.")

# This function is used to save the values of accuracy and time of AutoAttacks steps to plot a graph in a folloqing cell
def parse_autoattack_log(log: str, model, adv_images, labels, model_name):
    
    # Regex patterns
    pattern_init    = r'initial accuracy:\s*([\d\.]+)%'
    pattern_apgdce  = r'robust accuracy after APGD-CE:\s*([\d\.]+)% \(total time ([\d\.]+) s\)'
    pattern_apgdt   = r'robust accuracy after APGD-T:\s*([\d\.]+)% \(total time ([\d\.]+) s\)'
    pattern_fabt    = r'robust accuracy after FAB-T:\s*([\d\.]+)% \(total time ([\d\.]+) s\)'
    pattern_square  = r'robust accuracy after SQUARE:\s*([\d\.]+)% \(total time ([\d\.]+) s\)'

    m_init   = re.search(pattern_init, log)
    m_apgdce = re.search(pattern_apgdce, log)
    m_apgdt  = re.search(pattern_apgdt, log)
    m_fabt   = re.search(pattern_fabt, log)
    m_square = re.search(pattern_square, log)

    if m_init and m_apgdce and m_apgdt and m_fabt and m_square:
        initial_acc = float(m_init.group(1))
        apgdce_acc  = float(m_apgdce.group(1))
        apgdce_time = float(m_apgdce.group(2))
        apgdt_acc   = float(m_apgdt.group(1))
        apgdt_time  = float(m_apgdt.group(2))
        fabt_acc    = float(m_fabt.group(1))
        fabt_time   = float(m_fabt.group(2))
        square_acc  = float(m_square.group(1))
        square_time = float(m_square.group(2))
    else:
        print("Error: Unable to parse AutoAttack log output.")
        return {}

    # Build and return the attack_progress dictionary
    aa_times = [0.0, apgdce_time, apgdt_time, fabt_time, square_time]
    aa_accuracies = [initial_acc, apgdce_acc, apgdt_acc, fabt_acc, square_acc]
    aa_steps = ["Initial", "APGD-CE", "APGD-T", "FAB-T", "SQUARE"]

    attack_progress[model_name] = list(zip(aa_times, aa_accuracies, aa_steps))

    return {model_name: list(zip(aa_times, aa_accuracies, aa_steps))}
